// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, as_number, badge, debug, echo, help, info, log, rpr, unique, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'INTERSKIPLIST';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  this["new"] = function(settings) {
    var R, substrate;
    if (settings != null) {
      throw new Error("settings not yet supported");
    }
    substrate = new (require('interval-skip-list'))();
    R = {
      '~isa': 'CND/interskiplist',
      '%self': substrate,
      'entry-by-ids': {},
      'idx-by-names': {},
      'ids-by-names': {},
      'name-by-ids': {},
      'idx': -1
    };
    return R;
  };

  as_number = function(x) {
    var length;
    if ((x === (-Infinity) || x === (+Infinity)) || CND.isa_number(x)) {
      return x;
    }
    if ((CND.type_of(x)) !== 'text') {
      throw new Error("expected number or single character text, got a " + type);
    }
    if ((length = (Array.from(x)).length) !== 1) {
      throw new Error("expected single character text, got one of length " + length);
    }
    return x.codePointAt(0);
  };

  this.insert = function(me, entry) {
    var arity, base, global_idx, group_idx, hi, id, lo, name, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_pod(entry)) {
      throw new Error("expected a POD, got a " + (CND.type_of(entry)));
    }
    lo = entry.lo, hi = entry.hi, id = entry.id, name = entry.name;
    if (lo == null) {
      throw new Error("expected setting for 'lo', found none");
    }
    if (hi == null) {
      throw new Error("expected setting for 'hi', found none");
    }
    if (!((name != null) || (id != null))) {
      throw new Error("expected at least one setting for 'name' or 'id', found none");
    }
    lo = as_number(lo);
    hi = as_number(hi);
    if (name == null) {
      name = '*';
    }
    group_idx = (me['idx-by-names'][name] = ((ref = me['idx-by-names'][name]) != null ? ref : -1) + 1);
    global_idx = (me['idx'] += +1);
    if (id == null) {
      id = name + "[" + group_idx + "]";
    }
    entry['size'] = hi - lo + 1;
    entry['id'] = id;
    entry['idx'] = global_idx;
    entry['name'] = name;
    me['name-by-ids'][id] = name;
    me['entry-by-ids'][id] = entry != null ? entry : null;
    ((base = me['ids-by-names'])[name] != null ? base[name] : base[name] = []).push(id);
    me['%self'].insert(id, lo, hi);
    return id;
  };

  this.remove = function(me, id) {
    return me['%self'].remove(id);
  };

  this.interval_of = function(me, id) {
    return me['%self'].intervalsByMarker[id];
  };

  this.entry_of = function(me, id) {
    return me['entry-by-ids'][id];
  };

  this.name_of = function(me, id) {
    return me['name-by-ids'][id];
  };

  this.intervals_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['%self'].intervalsByMarker;
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.interval_of(me, id));
      }
      return results;
    }).call(this);
  };

  this.entries_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['entry-by-ids'];
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.entry_of(me, id));
      }
      return results;
    }).call(this);
  };

  this.names_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['name-by-ids'];
    }
    return unique((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.name_of(me, id));
      }
      return results;
    }).call(this));
  };

  this.find_ids_with_any_points = function() {
    var me, points, ref;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];

    /* Note: `Intervalskiplist::findIntersecting` needs more than a single probe, so we fall back to
    `::findContaining` in case a single probe was given.
     */
    if (CND.isa_list(points[0])) {
      return this.find_ids_with_any_points.apply(this, [me].concat(slice.call(points[0])));
    }
    if (points.length < 2) {
      return this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points)));
    }
    return (ref = me['%self']).findIntersecting.apply(ref, points);
  };

  this.find_ids_with_all_points = function() {
    var me, points, ref;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (CND.isa_list(points[0])) {
      return this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points[0])));
    }
    return (ref = me['%self']).findContaining.apply(ref, points);
  };

  this.find_entries_with_any_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.entries_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(points))));
  };

  this.find_entries_with_all_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.entries_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points))));
  };

  this.find_names_with_any_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.names_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(points))));
  };

  this.find_names_with_all_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.names_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points))));
  };

  unique = function(list) {
    var R, element, i, len, seen;
    seen = new Set();
    R = [];
    for (i = 0, len = list.length; i < len; i++) {
      element = list[i];
      if (seen.has(element)) {
        continue;
      }
      seen.add(element);
      R.push(element);
    }
    return R;
  };

  this.sort_entries = function(me, entries) {
    entries.sort(function(a, b) {
      var a_idx, a_size, b_idx, b_size, ref, ref1;
      ref = [a['size'], b['size']], a_size = ref[0], b_size = ref[1];
      if (a_size > b_size) {
        return -1;
      }
      if (a_size < b_size) {
        return +1;
      }
      ref1 = [a['idx'], b['idx']], a_idx = ref1[0], b_idx = ref1[1];
      if (a_idx > b_idx) {
        return +1;
      }
      if (a_idx < b_idx) {
        return -1;
      }
      return 0;
    });
    return entries;
  };

  this.aggregate = function() {
    var R, averages, cache, entries, entry, facets, i, j, key, len, me, points, reducer, reducers, ref, ref1, ref2, value;
    me = arguments[0], points = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), reducers = arguments[i++];
    if (!CND.isa_pod(reducers)) {
      points.push(reducers);
      reducers = {};
    }
    entries = this.find_entries_with_all_points.apply(this, [me].concat(slice.call(points)));
    this.sort_entries(me, entries);
    R = {};
    cache = {};
    averages = {};
    for (j = 0, len = entries.length; j < len; j++) {
      entry = entries[j];
      for (key in entry) {
        value = entry[key];
        if (key === 'idx' || key === 'id' || key === 'name' || key === 'lo' || key === 'hi' || key === 'size') {
          continue;
        }
        switch ((ref = (reducer = reducers[key])) != null ? ref : 'assign') {
          case 'skip':
            continue;
          case 'list':
            (R[key] != null ? R[key] : R[key] = []).push(value);
            break;
          case 'add':
            R[key] = ((ref1 = R[key]) != null ? ref1 : 0) + value;
            break;
          case 'assign':
            R[key] = value;
            break;
          case 'average':
            averages[key] = ((ref2 = averages[key]) != null ? ref2 : 0) + value;
            break;
          default:
            if (!CND.isa_function(reducer)) {
              throw new Error("unknwon reducer " + (rpr(reducer)));
            }
            (cache[key] != null ? cache[key] : cache[key] = []).push([entry['id'], value]);
        }
      }
    }
    for (key in cache) {
      facets = cache[key];
      R[key] = reducers[key](facets, R, entries);
    }
    return R;
  };

}).call(this);

//# sourceMappingURL=main.js.map
