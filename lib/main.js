// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, as_number, as_numbers, badge, debug, echo, help, info, log, rpr, unique, urge, warn, whisper,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'INTERSKIPLIST';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  this["new"] = function(settings) {
    var R, substrate;
    if (settings != null) {
      throw new Error("settings not yet supported");
    }
    substrate = new (require('interval-skip-list'))();
    R = {
      '~isa': 'CND/interskiplist',
      '%self': substrate,
      'entry-by-ids': {},
      'idx-by-names': {},
      'ids-by-names': {},
      'name-by-ids': {},
      'idx-by-ids': {},
      'ids': [],
      'idx': -1,
      'min': null,
      'max': null,
      'fmin': null,
      'fmax': null
    };
    return R;
  };

  as_number = function(x) {
    var length, type;
    if ((x === (-Infinity) || x === (+Infinity)) || CND.isa_number(x)) {
      return x;
    }
    if ((type = CND.type_of(x)) !== 'text') {
      throw new Error("expected number or single character text, got a " + type);
    }
    if ((length = (Array.from(x)).length) !== 1) {
      throw new Error("expected single character text, got one of length " + length);
    }
    return x.codePointAt(0);
  };

  as_numbers = function(list) {
    var i, len, results, x;
    results = [];
    for (i = 0, len = list.length; i < len; i++) {
      x = list[i];
      results.push(as_number(x));
    }
    return results;
  };

  this.insert = function(me, entry) {
    var arity, base, global_idx, group_idx, hi, id, lo, name, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_pod(entry)) {
      throw new Error("expected a POD, got a " + (CND.type_of(entry)));
    }
    lo = entry.lo, hi = entry.hi, id = entry.id, name = entry.name;
    if (lo == null) {
      throw new Error("expected setting for 'lo', found none");
    }
    if (hi == null) {
      throw new Error("expected setting for 'hi', found none");
    }
    lo = as_number(lo);
    hi = as_number(hi);
    if (name == null) {
      name = '+';
    }
    group_idx = (me['idx-by-names'][name] = ((ref = me['idx-by-names'][name]) != null ? ref : -1) + 1);
    global_idx = (me['idx'] += +1);
    if (id == null) {
      id = name + "[" + group_idx + "]";
    }
    entry['lo'] = lo;
    entry['hi'] = hi;
    entry['idx'] = global_idx;
    entry['id'] = id;
    entry['name'] = name;
    entry['size'] = hi - lo + 1;
    if (me['min'] == null) {
      me['min'] = lo;
    }
    me['min'] = Math.min(me['min'], lo);
    if (me['max'] == null) {
      me['max'] = hi;
    }
    me['max'] = Math.max(me['max'], lo);
    if (CND.isa_number(lo)) {
      if (me['fmin'] == null) {
        me['fmin'] = lo;
      }
      me['fmin'] = Math.min(me['fmin'], lo);
    }
    if (CND.isa_number(hi)) {
      if (me['fmax'] == null) {
        me['fmax'] = hi;
      }
      me['fmax'] = Math.max(me['fmax'], lo);
    }
    me['name-by-ids'][id] = name;
    me['idx-by-ids'][id] = global_idx;
    me['entry-by-ids'][id] = entry != null ? entry : null;
    ((base = me['ids-by-names'])[name] != null ? base[name] : base[name] = []).push(id);
    me['%self'].insert(id, lo, hi);
    me['ids'].push(id);
    return id;
  };

  this.remove = function(me, id) {
    return me['%self'].remove(id);
  };

  this.interval_of = function(me, id) {
    var R;
    if ((R = me['%self'].intervalsByMarker[id]) == null) {
      throw new Error("unknown ID " + (rpr(id)));
    }
    return R;
  };

  this.entry_of = function(me, id) {
    var R;
    if ((R = me['entry-by-ids'][id]) == null) {
      throw new Error("unknown ID " + (rpr(id)));
    }
    return R;
  };

  this.name_of = function(me, id) {
    var R;
    if ((R = me['name-by-ids'][id]) == null) {
      throw new Error("unknown ID " + (rpr(id)));
    }
    return R;
  };

  this._intervals_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['%self'].intervalsByMarker;
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.interval_of(me, id));
      }
      return results;
    }).call(this);
  };

  this._entries_of = function(me, ids) {
    var _, entry, id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return (function() {
        var ref, results;
        ref = me['entry-by-ids'];
        results = [];
        for (_ in ref) {
          entry = ref[_];
          results.push(entry);
        }
        return results;
      })();
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.entry_of(me, id));
      }
      return results;
    }).call(this);
  };

  this._names_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['name-by-ids'];
    }
    return unique((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.name_of(me, id));
      }
      return results;
    }).call(this));
  };

  this.intervals_of = function(me, ids) {
    if (ids == null) {
      ids = null;
    }
    return this._intervals_of(me, ids != null ? this.sort_ids(me, ids) : null);
  };

  this.entries_of = function(me, ids) {
    if (ids == null) {
      ids = null;
    }
    return this._entries_of(me, ids != null ? this.sort_ids(me, ids) : null);
  };

  this.names_of = function(me, ids) {
    if (ids == null) {
      ids = null;
    }
    return this._names_of(me, ids != null ? this.sort_ids(me, ids) : null);
  };

  this.find_ids = function(me, point) {
    return this.find_ids_with_all_points(me, point);
  };

  this.find_intervals = function(me, point) {
    return this.find_intervals_with_all_points(me, point);
  };

  this.find_entries = function(me, point) {
    return this.find_entries_with_all_points(me, point);
  };

  this.find_names = function(me, point) {
    return this.find_names_with_all_points(me, point);
  };


  /* TAINT what happens when these methods are called with no points? */

  this.find_entries_with_any_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.entries_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_names_with_any_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.names_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_intervals_with_any_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.intervals_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_entries_with_all_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.entries_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_intervals_with_all_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.intervals_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_ids_with_any_points = function(me, points) {

    /* TAINT should be possible to call w/o any points to get all IDs */
    var R, arity, i, id, ids, j, len, len1, point;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_list(points)) {
      points = [points];
    }

    /* Note: `Intervalskiplist::findIntersecting` needs more than a single probe, so we fall back to
    `::findContaining` in case a single probe was given.
     */
    if (points.length < 2) {
      return this.find_ids_with_all_points(me, points);
    }
    points = as_numbers(points);

    /* TAINT findIntersecting appears to be not working as advertised; workaraound: */
    R = new Set();
    for (i = 0, len = points.length; i < len; i++) {
      point = points[i];
      ids = me['%self'].findContaining(point);
      for (j = 0, len1 = ids.length; j < len1; j++) {
        id = ids[j];
        R.add(id);
      }
    }
    return this.sort_ids(me, Array.from(R));
  };

  this.find_ids_with_all_points = function(me, points) {

    /* TAINT should be possible to call w/o any points to get no IDs */
    var arity, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_list(points)) {
      points = [points];
    }
    points = as_numbers(points);
    return (ref = me['%self']).findContaining.apply(ref, points);
  };

  this.find_names_with_all_points = function(me, points) {

    /* TAINT should be possible to call w/o any points to get no names */
    var R, arity, i, names, point, point_idx, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_list(points)) {
      points = [points];
    }
    if (points.length === 0) {
      return [];
    }
    R = this.find_names_with_any_points(me, points[0]);
    if (points.length < 2) {
      return R;
    }
    R = new Set(R);
    for (point_idx = i = 1, ref = points.length; 1 <= ref ? i < ref : i > ref; point_idx = 1 <= ref ? ++i : --i) {
      point = points[point_idx];
      names = this.find_names_with_any_points(me, point);
      R.forEach(function(name) {
        if (indexOf.call(names, name) < 0) {
          return R["delete"](name);
        }
      });
    }
    return Array.from(R);
  };

  this.intervals_from_points = function() {
    var R, i, last_hi, last_lo, last_point, len, me, mixin, mixins, point, points;
    me = arguments[0], points = arguments[1], mixins = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    mixin = function(lohi) {
      if (!(mixins.length > 0)) {
        return lohi;
      }
      return Object.assign.apply(Object, [{}].concat(slice.call(mixins), [lohi]));
    };
    if (!CND.isa_list(points)) {
      points = [points];
    }
    points = unique(as_numbers(points));
    points.sort(function(a, b) {
      if (a > b) {
        return +1;
      }
      if (a < b) {
        return -1;
      }
      return 0;
    });
    R = [];
    last_point = null;
    last_lo = null;
    last_hi = null;
    for (i = 0, len = points.length; i < len; i++) {
      point = points[i];
      if (last_lo == null) {
        last_lo = point;
        last_hi = point;
        last_point = point;
        continue;
      }
      if (point === last_point + 1) {
        last_hi = point;
        last_point = point;
        continue;
      }
      R.push(mixin({
        lo: last_lo,
        hi: last_hi
      }));
      last_lo = point;
      last_hi = point;
      last_point = point;
    }
    if ((last_lo != null) && (last_hi != null)) {
      R.push(mixin({
        lo: last_lo,
        hi: last_hi
      }));
    }
    return R;
  };

  unique = function(list) {
    var R, element, i, len, seen;
    seen = new Set();
    R = [];
    for (i = 0, len = list.length; i < len; i++) {
      element = list[i];
      if (seen.has(element)) {
        continue;
      }
      seen.add(element);
      R.push(element);
    }
    return R;
  };

  this.sort_entries = function(me, entries) {
    entries.sort(function(a, b) {
      if (a['idx'] > b['idx']) {
        return +1;
      }
      if (a['idx'] < b['idx']) {
        return -1;
      }
      return 0;
    });
    return entries;
  };

  this.sort_ids = function(me, ids) {
    var idxs;
    idxs = me['idx-by-ids'];
    ids.sort(function(a, b) {
      if (idxs[a] > idxs[b]) {
        return +1;
      }
      if (idxs[a] < idxs[b]) {
        return -1;
      }
      return 0;
    });
    return ids;
  };

  this.aggregate = function(me, points_or_entries, reducers) {
    var R, averages, cache, common, count, entries, entry, exclude, i, ids_and_values, j, key, len, len1, points, points_or_entry, reducer, reducer_fallback, ref, ref1, ref2, ref3, ref4, sum, target, value, values;
    if (reducers == null) {
      reducers = {};
    }
    if ((reducers != null) && !CND.isa_pod(reducers)) {
      throw new Error("expected a POD for reducer, got a " + (CND.type_of(reducers)));
    }

    /* Separate points from entries, splice them together with those points found for the points, and sort
    the result:
     */
    if (!CND.isa_list(points_or_entries)) {
      points_or_entries = [points_or_entries];
    }
    points = [];
    entries = [];
    for (i = 0, len = points_or_entries.length; i < len; i++) {
      points_or_entry = points_or_entries[i];
      if ((ref = CND.type_of(points_or_entry)) === 'number' || ref === 'text') {
        points.push(points_or_entry);
      } else {
        entries.push(points_or_entry);
      }
    }
    if (points.length > 0) {
      entries.splice.apply(entries, [0, 0].concat(slice.call(this.find_entries_with_all_points(me, points))));
    }
    this.sort_entries(me, entries);
    R = {};
    cache = {};
    averages = {};
    common = {};
    exclude = (function() {
      var j, len1, ref1, results;
      ref1 = ['idx', 'id', 'lo', 'hi', 'size'];
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        key = ref1[j];
        if (!(key in reducers)) {
          results.push(key);
        }
      }
      return results;
    })();
    reducer_fallback = (ref1 = reducers['*']) != null ? ref1 : 'assign';
    for (j = 0, len1 = entries.length; j < len1; j++) {
      entry = entries[j];
      for (key in entry) {
        value = entry[key];
        if (indexOf.call(exclude, key) >= 0) {
          continue;
        }
        reducer = (ref2 = (reducer = reducers[key])) != null ? ref2 : reducer_fallback;
        if (reducer === 'include') {
          reducer = reducer_fallback;
        }
        switch (reducer) {
          case 'skip':
            continue;
          case 'list':
            (R[key] != null ? R[key] : R[key] = []).push(value);
            break;
          case 'add':
            R[key] = ((ref3 = R[key]) != null ? ref3 : 0) + value;
            break;
          case 'assign':
            R[key] = value;
            break;
          case 'average':
            target = averages[key] != null ? averages[key] : averages[key] = [0, 0];
            target[0] = target[0] + value;
            target[1] = target[1] + 1;
            break;
          default:

            /* TAINT repeats typecheck on each iteration */
            if (!CND.isa_function(reducer)) {
              throw new Error("unknwon reducer " + (rpr(reducer)));
            }
            (cache[key] != null ? cache[key] : cache[key] = []).push([entry['id'], value]);
        }
      }
    }
    for (key in averages) {
      ref4 = averages[key], sum = ref4[0], count = ref4[1];
      R[key] = sum / count;
    }
    for (key in common) {
      values = common[key];
      if ((values.length === 1) || CND.equals.apply(CND, values)) {
        R[key] = values[0];
      }
    }
    for (key in cache) {
      ids_and_values = cache[key];
      R[key] = reducers[key](ids_and_values, R, entries);
    }
    return R;
  };

}).call(this);

//# sourceMappingURL=main.js.map
