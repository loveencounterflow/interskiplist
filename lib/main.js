// Generated by CoffeeScript 1.10.0
(function() {
  var CND,
    slice = [].slice;

  CND = require('cnd');

  this["new"] = function(settings) {
    var R, substrate;
    if (settings != null) {
      throw new Error("settings not yet supported");
    }
    substrate = new (require('interval-skip-list'))();
    R = {
      '~isa': 'CND/interskiplist',
      '%self': substrate,
      'value-by-ids': {}
    };
    return R;
  };

  this.add_interval = function(me, lo, hi, id, value) {
    if (id == null) {
      throw new Error("need an ID");
    }
    if (value === void 0) {
      value = id;
    }
    me['%self'].insert(id, lo, hi);
    me['value-by-ids'][id] = value != null ? value : null;
    return id;
  };

  this.get_intervals = function(me) {
    return me['%self'].intervalsByMarker;
  };

  this.get_interval = function(me, id) {
    return (this.get_intervals(me))[id];
  };

  this.get_values = function(me) {
    return me['value-by-ids'];
  };

  this.get_value = function(me, id) {
    return (this.get_values(me))[id];
  };

  this.find_any_ids = function() {
    var me, probes, ref;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];

    /* Note: `Intervalskiplist::findIntersecting` needs more than a single probe, so we fall back to
    `::findContaining` in case a single probe was given.
     */
    if (probes.length < 2) {
      return this.find_all_ids.apply(this, [me].concat(slice.call(probes)));
    }
    return (ref = me['%self']).findIntersecting.apply(ref, probes);
  };

  this.find_all_ids = function() {
    var me, probes, ref;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (ref = me['%self']).findContaining.apply(ref, probes);
  };

  this.find_any_intervals = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_any_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_interval(me, id));
      }
      return results;
    }).call(this);
  };

  this.find_all_intervals = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_all_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_interval(me, id));
      }
      return results;
    }).call(this);
  };

  this.find_any_values = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_any_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_value(me, id));
      }
      return results;
    }).call(this);
  };

  this.find_all_values = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_all_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_value(me, id));
      }
      return results;
    }).call(this);
  };

}).call(this);

//# sourceMappingURL=main.js.map
