// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, badge, debug, echo, help, info, log, rpr, unique, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'INTERSKIPLIST';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  this["new"] = function(settings) {
    var R, substrate;
    if (settings != null) {
      throw new Error("settings not yet supported");
    }
    substrate = new (require('interval-skip-list'))();
    R = {
      '~isa': 'CND/interskiplist',
      '%self': substrate,
      'value-by-ids': {},
      'count-by-names': {},
      'ids-by-names': {},
      'name-by-ids': {}
    };
    return R;
  };

  this.insert = function(me, settings) {
    var arity, base, hi, id, idx, lo, name, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_pod(settings)) {
      throw new Error("expected a POD, got a " + (CND.type_of(settings)));
    }
    lo = settings.lo, hi = settings.hi, id = settings.id, name = settings.name;
    if (lo == null) {
      throw new Error("expected setting for 'lo', found none");
    }
    if (hi == null) {
      throw new Error("expected setting for 'hi', found none");
    }
    if (!((name != null) || (id != null))) {
      throw new Error("expected at least one setting for 'name' or 'id', found none");
    }
    if (name == null) {
      name = '*';
    }
    idx = (me['count-by-names'][name] = ((ref = me['count-by-names'][name]) != null ? ref : 0) + 1) - 1;
    if (id == null) {
      id = name + "[" + idx + "]";
    }
    settings['id'] = id;
    settings['name'] = name;
    me['name-by-ids'][id] = name;
    ((base = me['ids-by-names'])[name] != null ? base[name] : base[name] = []).push(id);
    return this._insert(me, lo, hi, id, settings);
  };

  this._insert = function(me, lo, hi, id, value) {
    if (id == null) {
      throw new Error("need an ID");
    }
    if (value === void 0) {
      value = id;
    }
    me['%self'].insert(id, lo, hi);
    me['value-by-ids'][id] = value != null ? value : null;
    return id;
  };

  this.remove = function(me, id) {
    return me['%self'].remove(id);
  };

  this.interval_of = function(me, id) {
    return me['%self'].intervalsByMarker[id];
  };

  this.value_of = function(me, id) {
    return me['value-by-ids'][id];
  };

  this.name_of = function(me, id) {
    return me['name-by-ids'][id];
  };

  this.intervals_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['%self'].intervalsByMarker;
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.interval_of(me, id));
      }
      return results;
    }).call(this);
  };

  this.values_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['value-by-ids'];
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.value_of(me, id));
      }
      return results;
    }).call(this);
  };

  this.names_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['name-by-ids'];
    }
    return unique((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.name_of(me, id));
      }
      return results;
    }).call(this));
  };

  this.find_ids_with_any_points = function() {
    var me, points, ref;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];

    /* Note: `Intervalskiplist::findIntersecting` needs more than a single probe, so we fall back to
    `::findContaining` in case a single probe was given.
     */
    if (CND.isa_list(points[0])) {
      return this.find_ids_with_any_points.apply(this, [me].concat(slice.call(points[0])));
    }
    if (points.length < 2) {
      return this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points)));
    }
    return (ref = me['%self']).findIntersecting.apply(ref, points);
  };

  this.find_ids_with_all_points = function() {
    var me, points, ref;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (CND.isa_list(points[0])) {
      return this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points[0])));
    }
    return (ref = me['%self']).findContaining.apply(ref, points);
  };

  this.find_values_with_any_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.values_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(points))));
  };

  this.find_values_with_all_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.values_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points))));
  };

  this.find_names_with_any_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.names_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(points))));
  };

  this.find_names_with_all_points = function() {
    var me, points;
    me = arguments[0], points = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.names_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(points))));
  };

  unique = function(list) {
    var R, element, i, len, seen;
    seen = new Set();
    R = [];
    for (i = 0, len = list.length; i < len; i++) {
      element = list[i];
      if (seen.has(element)) {
        continue;
      }
      seen.add(element);
      R.push(element);
    }
    return R;
  };

}).call(this);

//# sourceMappingURL=main.js.map
