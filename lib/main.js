// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, append, as_number, as_numbers, badge, debug, echo, fuse, help, info, log, meld, rpr, unique, urge, warn, whisper,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'INTERSKIPLIST';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  this["new"] = function(settings) {
    var R, ref, substrate;
    substrate = new (require('interval-skip-list'))();
    substrate.toString = substrate.inspect = function() {
      return "{ interval-skip-list }";
    };
    R = {
      '~isa': 'CND/interskiplist',
      '%self': substrate,
      'entry-by-ids': {},
      'idx-by-names': {},
      'ids-by-names': {},
      'name-by-ids': {},
      'idx-by-ids': {},
      'ids': [],
      'idx': -1,
      'min': null,
      'max': null,
      'fmin': null,
      'fmax': null,
      'reducers': (ref = settings != null ? settings['reducers'] : void 0) != null ? ref : null
    };
    return R;
  };

  this.insert = function(me, entry) {
    var arity, base, global_idx, group_idx, hi, id, lo, name, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_pod(entry)) {
      throw new Error("expected a POD, got a " + (CND.type_of(entry)));
    }
    lo = entry.lo, hi = entry.hi, id = entry.id, name = entry.name;
    if (lo == null) {
      throw new Error("expected setting for 'lo', found none");
    }
    if (hi == null) {
      throw new Error("expected setting for 'hi', found none");
    }
    lo = as_number(lo);
    hi = as_number(hi);
    if (name == null) {
      name = '+';
    }
    group_idx = (me['idx-by-names'][name] = ((ref = me['idx-by-names'][name]) != null ? ref : -1) + 1);
    global_idx = (me['idx'] += +1);
    if (id == null) {
      id = name + "[" + group_idx + "]";
    }
    entry['lo'] = lo;
    entry['hi'] = hi;
    entry['idx'] = global_idx;
    entry['id'] = id;
    entry['name'] = name;
    entry['size'] = hi - lo + 1;
    if (me['min'] == null) {
      me['min'] = lo;
    }
    me['min'] = Math.min(me['min'], lo);
    if (me['max'] == null) {
      me['max'] = hi;
    }
    me['max'] = Math.max(me['max'], lo);
    if (CND.isa_number(lo)) {
      if (me['fmin'] == null) {
        me['fmin'] = lo;
      }
      me['fmin'] = Math.min(me['fmin'], lo);
    }
    if (CND.isa_number(hi)) {
      if (me['fmax'] == null) {
        me['fmax'] = hi;
      }
      me['fmax'] = Math.max(me['fmax'], lo);
    }
    me['name-by-ids'][id] = name;
    me['idx-by-ids'][id] = global_idx;
    me['entry-by-ids'][id] = entry != null ? entry : null;
    ((base = me['ids-by-names'])[name] != null ? base[name] : base[name] = []).push(id);
    me['%self'].insert(id, lo, hi);
    me['ids'].push(id);
    return id;
  };

  this.remove = function(me, id) {
    return me['%self'].remove(id);
  };

  this.interval_of = function(me, id) {
    var R;
    if ((R = me['%self'].intervalsByMarker[id]) == null) {
      throw new Error("unknown ID " + (rpr(id)));
    }
    return R;
  };

  this.entry_of = function(me, id) {
    var R;
    if ((R = me['entry-by-ids'][id]) == null) {
      throw new Error("unknown ID " + (rpr(id)));
    }
    return R;
  };

  this.name_of = function(me, id) {
    var R;
    if ((R = me['name-by-ids'][id]) == null) {
      throw new Error("unknown ID " + (rpr(id)));
    }
    return R;
  };

  this.tag_of = function(me, id) {

    /* NOTE always returns a (possibly empty) list; always returns a copy, never the original list */
    var R, entry;
    if ((entry = me['entry-by-ids'][id]) == null) {
      throw new Error("unknown ID " + (rpr(id)));
    }
    R = entry['tag'];
    if (R == null) {
      return [];
    }
    return meld([], R);
  };

  this._intervals_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['%self'].intervalsByMarker;
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.interval_of(me, id));
      }
      return results;
    }).call(this);
  };

  this._entries_of = function(me, ids) {
    var _, entry, id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return (function() {
        var ref, results;
        ref = me['entry-by-ids'];
        results = [];
        for (_ in ref) {
          entry = ref[_];
          results.push(entry);
        }
        return results;
      })();
    }
    return (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.entry_of(me, id));
      }
      return results;
    }).call(this);
  };

  this._names_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      return me['name-by-ids'];
    }
    return unique((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.name_of(me, id));
      }
      return results;
    }).call(this));
  };

  this._tags_of = function(me, ids) {
    var id;
    if (ids == null) {
      ids = null;
    }
    if (ids == null) {
      throw new Error("retrieving tags without IDs not implemented");
    }
    return fuse((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = ids.length; i < len; i++) {
        id = ids[i];
        results.push(this.tag_of(me, id));
      }
      return results;
    }).call(this));
  };

  this.intervals_of = function(me, ids) {
    if (ids == null) {
      ids = null;
    }
    return this._intervals_of(me, ids != null ? this.sort_ids(me, ids) : null);
  };

  this.entries_of = function(me, ids) {
    if (ids == null) {
      ids = null;
    }
    return this._entries_of(me, ids != null ? this.sort_ids(me, ids) : null);
  };

  this.names_of = function(me, ids) {
    if (ids == null) {
      ids = null;
    }
    return this._names_of(me, ids != null ? this.sort_ids(me, ids) : null);
  };

  this.tags_of = function(me, ids) {
    if (ids == null) {
      ids = null;
    }
    return this._tags_of(me, ids != null ? this.sort_ids(me, ids) : null);
  };

  this.find_ids = function(me, point) {
    return this.find_ids_with_all_points(me, point);
  };

  this.find_intervals = function(me, point) {
    return this.find_intervals_with_all_points(me, point);
  };

  this.find_entries = function(me, point) {
    return this.find_entries_with_all_points(me, point);
  };

  this.find_names = function(me, point) {
    return this.find_names_with_all_points(me, point);
  };

  this.find_tags = function(me, point) {
    return this.find_tags_with_all_points(me, point);
  };


  /* TAINT what happens when these methods are called with no points? */

  this.find_entries_with_any_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.entries_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_names_with_any_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.names_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_intervals_with_any_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.intervals_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_tags_with_any_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.tags_of(me, this.find_ids_with_any_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_entries_with_all_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.entries_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_intervals_with_all_points = function() {
    var P, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.intervals_of(me, this.find_ids_with_all_points.apply(this, [me].concat(slice.call(P))));
  };

  this.find_ids_with_any_points = function(me, points) {

    /* TAINT should be possible to call w/o any points to get all IDs */
    var R, arity, i, id, ids, j, len, len1, point;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_list(points)) {
      points = [points];
    }

    /* Note: `Intervalskiplist::findIntersecting` needs more than a single probe, so we fall back to
    `::findContaining` in case a single probe was given.
     */
    if (points.length < 2) {
      return this.find_ids_with_all_points(me, points);
    }
    points = as_numbers(points);

    /* TAINT findIntersecting appears to be not working as advertised; workaraound: */
    R = new Set();
    for (i = 0, len = points.length; i < len; i++) {
      point = points[i];
      ids = me['%self'].findContaining(point);
      for (j = 0, len1 = ids.length; j < len1; j++) {
        id = ids[j];
        R.add(id);
      }
    }
    return this.sort_ids(me, Array.from(R));
  };

  this.find_ids_with_all_points = function(me, points) {

    /* TAINT should be possible to call w/o any points to get no IDs */
    var arity, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_list(points)) {
      points = [points];
    }
    points = as_numbers(points);
    return (ref = me['%self']).findContaining.apply(ref, points);
  };

  this.find_names_with_all_points = function(me, points) {

    /* TAINT code duplication */
    var R, arity, i, names, point, point_idx, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_list(points)) {
      points = [points];
    }
    if (points.length === 0) {
      return [];
    }
    R = this.find_names_with_any_points(me, points[0]);
    if (points.length < 2) {
      return R;
    }
    R = new Set(R);
    for (point_idx = i = 1, ref = points.length; 1 <= ref ? i < ref : i > ref; point_idx = 1 <= ref ? ++i : --i) {
      point = points[point_idx];
      names = this.find_names_with_any_points(me, point);
      R.forEach(function(name) {
        if (indexOf.call(names, name) < 0) {
          return R["delete"](name);
        }
      });
    }
    return Array.from(R);
  };

  this.find_tags_with_all_points = function(me, points) {

    /* TAINT code duplication */
    var R, arity, i, point, point_idx, ref, tags;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_list(points)) {
      points = [points];
    }
    if (points.length === 0) {
      return [];
    }
    R = this.find_tags_with_any_points(me, points[0]);
    if (points.length < 2) {
      return R;
    }
    R = new Set(R);
    for (point_idx = i = 1, ref = points.length; 1 <= ref ? i < ref : i > ref; point_idx = 1 <= ref ? ++i : --i) {
      point = points[point_idx];
      tags = this.find_tags_with_any_points(me, point);
      R.forEach(function(tag) {
        if (indexOf.call(tags, tag) < 0) {
          return R["delete"](tag);
        }
      });
    }
    return Array.from(R);
  };

  this.intervals_from_points = function() {
    var R, i, last_hi, last_lo, last_point, len, me, mixin, mixins, point, points;
    me = arguments[0], points = arguments[1], mixins = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    mixin = function(lohi) {
      if (!(mixins.length > 0)) {
        return lohi;
      }
      return Object.assign.apply(Object, [{}].concat(slice.call(mixins), [lohi]));
    };
    if (!CND.isa_list(points)) {
      points = [points];
    }
    points = unique(as_numbers(points));
    points.sort(function(a, b) {
      if (a > b) {
        return +1;
      }
      if (a < b) {
        return -1;
      }
      return 0;
    });
    R = [];
    last_point = null;
    last_lo = null;
    last_hi = null;
    for (i = 0, len = points.length; i < len; i++) {
      point = points[i];
      if (last_lo == null) {
        last_lo = point;
        last_hi = point;
        last_point = point;
        continue;
      }
      if (point === last_point + 1) {
        last_hi = point;
        last_point = point;
        continue;
      }
      R.push(mixin({
        lo: last_lo,
        hi: last_hi
      }));
      last_lo = point;
      last_hi = point;
      last_point = point;
    }
    if ((last_lo != null) && (last_hi != null)) {
      R.push(mixin({
        lo: last_lo,
        hi: last_hi
      }));
    }
    return R;
  };

  this.sort_entries = function(me, entries) {
    entries.sort(function(a, b) {
      if (a['idx'] > b['idx']) {
        return +1;
      }
      if (a['idx'] < b['idx']) {
        return -1;
      }
      return 0;
    });
    return entries;
  };

  this.sort_ids = function(me, ids) {
    var idxs;
    idxs = me['idx-by-ids'];
    ids.sort(function(a, b) {
      if (idxs[a] > idxs[b]) {
        return +1;
      }
      if (idxs[a] < idxs[b]) {
        return -1;
      }
      return 0;
    });
    return ids;
  };

  this.aggregate = function(me, points_or_entries, reducers) {
    var R, averages, cache, count, entries, entry, exclude, functions, i, ids_and_values, idx, j, k, key, len, len1, points, points_or_entry, reducer, reducer_fallback, ref, ref1, ref2, ref3, ref4, ref5, ref6, source, sum, tag, tag_keys, target, value;
    if (reducers == null) {
      reducers = {};
    }
    if ((reducers != null) && !CND.isa_pod(reducers)) {
      throw new Error("expected a POD for reducer, got a " + (CND.type_of(reducers)));
    }

    /* Separate points from entries, splice them together with those points found for the points, and sort
    the result:
     */
    if (!CND.isa_list(points_or_entries)) {
      points_or_entries = [points_or_entries];
    }
    points = [];
    entries = [];
    for (i = 0, len = points_or_entries.length; i < len; i++) {
      points_or_entry = points_or_entries[i];
      if ((ref = CND.type_of(points_or_entry)) === 'number' || ref === 'text') {
        points.push(points_or_entry);
      } else {
        entries.push(points_or_entry);
      }
    }
    if (points.length > 0) {
      append(entries, this.find_entries_with_all_points(me, points));
    }
    this.sort_entries(me, entries);
    R = {};
    cache = {};
    averages = {};
    reducers = Object.assign({}, reducers, (ref1 = me['reducers']) != null ? ref1 : {});
    tag_keys = (function() {
      var results;
      results = [];
      for (key in reducers) {
        value = reducers[key];
        if (value === 'tag') {
          results.push(key);
        }
      }
      return results;
    })();
    exclude = (function() {
      var j, len1, ref2, results;
      ref2 = ['idx', 'id', 'lo', 'hi', 'size'];
      results = [];
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        key = ref2[j];
        if (!(key in reducers)) {
          results.push(key);
        }
      }
      return results;
    })();
    reducer_fallback = (ref2 = reducers['*']) != null ? ref2 : 'assign';
    functions = {};
    for (key in reducers) {
      reducer = reducers[key];
      if (reducer === 'include') {
        reducers[key] = reducer_fallback;
        continue;
      }
      if (CND.isa_function(reducer)) {
        functions[key] = reducer;
        reducers[key] = 'function';
      }
    }
    if (!((indexOf.call(exclude, 'tag') >= 0) || ('tag' in reducers))) {
      tag_keys.push('tag');
      reducers['tag'] = 'tag';
    }
    for (j = 0, len1 = entries.length; j < len1; j++) {
      entry = entries[j];
      for (key in entry) {
        value = entry[key];
        if (indexOf.call(exclude, key) >= 0) {
          continue;
        }
        reducer = (ref3 = (reducer = reducers[key])) != null ? ref3 : reducer_fallback;
        switch (reducer) {
          case 'skip':
            continue;
          case 'list':
            (R[key] != null ? R[key] : R[key] = []).push(value);
            break;
          case 'add':
            R[key] = ((ref4 = R[key]) != null ? ref4 : 0) + value;
            break;
          case 'assign':
            R[key] = value;
            break;
          case 'tag':
            meld((target = R[key] != null ? R[key] : R[key] = []), value);
            break;
          case 'function':
            (cache[key] != null ? cache[key] : cache[key] = []).push([entry['id'], value]);
            break;
          case 'average':
            target = averages[key] != null ? averages[key] : averages[key] = [0, 0];
            target[0] = target[0] + value;
            target[1] = target[1] + 1;
            break;
          default:
            throw new Error("unknown reducer " + (rpr(reducer)));
        }
      }
    }

    /* tags */
    for (key in R) {
      value = R[key];
      if (indexOf.call(tag_keys, key) < 0) {
        continue;
      }
      source = fuse(value);
      target = [];
      exclude = null;
      for (idx = k = ref5 = source.length - 1; k >= 0; idx = k += -1) {
        tag = source[idx];
        if ((exclude != null) && exclude.has(tag)) {
          continue;
        }
        if (tag.startsWith('-')) {
          if (tag === '-*') {
            break;
          }
          (exclude != null ? exclude : exclude = new Set()).add(tag.slice(1));
          continue;
        }
        target.unshift(tag);
      }
      R[key] = target;
    }

    /* averages */
    for (key in averages) {
      ref6 = averages[key], sum = ref6[0], count = ref6[1];
      R[key] = sum / count;
    }

    /* functions */
    for (key in cache) {
      ids_and_values = cache[key];
      R[key] = functions[key](ids_and_values, R, entries);
    }
    return R;
  };

  as_number = function(x) {
    var length, type;
    if ((x === (-Infinity) || x === (+Infinity)) || CND.isa_number(x)) {
      return x;
    }
    if ((type = CND.type_of(x)) !== 'text') {
      throw new Error("expected number or single character text, got a " + type);
    }
    if ((length = (Array.from(x)).length) !== 1) {
      throw new Error("expected single character text, got one of length " + length);
    }
    return x.codePointAt(0);
  };

  as_numbers = function(list) {
    var i, len, results, x;
    results = [];
    for (i = 0, len = list.length; i < len; i++) {
      x = list[i];
      results.push(as_number(x));
    }
    return results;
  };

  unique = function(list) {
    var R, element, i, idx, ref, seen;
    seen = new Set();
    R = [];
    for (idx = i = ref = list.length - 1; i >= 0; idx = i += -1) {
      element = list[idx];
      if (seen.has(element)) {
        continue;
      }
      seen.add(element);
      R.unshift(element);
    }
    return R;
  };

  append = function(a, b) {
    a.splice.apply(a, [a.length, 0].concat(slice.call(b)));
    return a;
  };

  meld = function(list, value) {
    if (CND.isa_list(value)) {
      append(list, value);
    } else {
      list.push(value);
    }
    return list;
  };

  fuse = function(list) {
    var R, element, i, len;
    R = [];
    for (i = 0, len = list.length; i < len; i++) {
      element = list[i];
      meld(R, element);
    }
    R = unique(R);
    list.splice.apply(list, [0, list.length].concat(slice.call(R)));
    return list;
  };

}).call(this);

//# sourceMappingURL=main.js.map
