// Generated by CoffeeScript 1.10.0
(function() {
  var CND, alert, badge, debug, echo, help, info, log, rpr, unique, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'INTERSKIPLIST';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  this["new"] = function(settings) {
    var R, substrate;
    if (settings != null) {
      throw new Error("settings not yet supported");
    }
    substrate = new (require('interval-skip-list'))();
    R = {
      '~isa': 'CND/interskiplist',
      '%self': substrate,
      'value-by-ids': {},
      'count-by-names': {},
      'ids-by-names': {},
      'name-by-ids': {}
    };
    return R;
  };

  this.add_interval = function(me, settings) {
    var arity, base, hi, id, idx, lo, name, ref;
    if ((arity = arguments.length) !== 2) {
      throw new Error("expected 2 arguments, got " + arity);
    }
    if (!CND.isa_pod(settings)) {
      throw new Error("expected a POD, got a " + (CND.type_of(settings)));
    }
    lo = settings.lo, hi = settings.hi, id = settings.id, name = settings.name;
    if (lo == null) {
      throw new Error("expected setting for 'lo', found none");
    }
    if (hi == null) {
      throw new Error("expected setting for 'hi', found none");
    }
    if (!((name != null) || (id != null))) {
      throw new Error("expected at least one setting for 'name' or 'id', found none");
    }
    if (name == null) {
      name = '*';
    }
    idx = (me['count-by-names'][name] = ((ref = me['count-by-names'][name]) != null ? ref : 0) + 1) - 1;
    if (id == null) {
      id = name + "[" + idx + "]";
    }
    settings['id'] = id;
    settings['name'] = name;
    me['name-by-ids'][id] = name;
    ((base = me['ids-by-names'])[name] != null ? base[name] : base[name] = []).push(id);
    return this._add_interval(me, lo, hi, id, settings);
  };

  this._add_interval = function(me, lo, hi, id, value) {
    if (id == null) {
      throw new Error("need an ID");
    }
    if (value === void 0) {
      value = id;
    }
    me['%self'].insert(id, lo, hi);
    me['value-by-ids'][id] = value != null ? value : null;
    return id;
  };

  this.get_intervals = function(me) {
    return me['%self'].intervalsByMarker;
  };

  this.get_interval = function(me, id) {
    return (this.get_intervals(me))[id];
  };

  this.get_values = function(me) {
    return me['value-by-ids'];
  };

  this.get_value = function(me, id) {
    return (this.get_values(me))[id];
  };

  this.get_names = function(me) {
    return me['name-by-ids'];
  };

  this.get_name = function(me, id) {
    return (this.get_names(me))[id];
  };

  this.find_any_ids = function() {
    var me, probes, ref;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];

    /* Note: `Intervalskiplist::findIntersecting` needs more than a single probe, so we fall back to
    `::findContaining` in case a single probe was given.
     */
    if (probes.length < 2) {
      return this.find_all_ids.apply(this, [me].concat(slice.call(probes)));
    }
    return (ref = me['%self']).findIntersecting.apply(ref, probes);
  };

  this.find_all_ids = function() {
    var me, probes, ref;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (ref = me['%self']).findContaining.apply(ref, probes);
  };

  this.find_any_intervals = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_any_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_interval(me, id));
      }
      return results;
    }).call(this);
  };

  this.find_all_intervals = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_all_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_interval(me, id));
      }
      return results;
    }).call(this);
  };

  this.find_any_values = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_any_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_value(me, id));
      }
      return results;
    }).call(this);
  };

  this.find_all_names = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return (function() {
      var i, len, ref, results;
      ref = this.find_all_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_name(me, id));
      }
      return results;
    }).call(this);
  };

  this.find_any_names = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return unique((function() {
      var i, len, ref, results;
      ref = this.find_any_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_name(me, id));
      }
      return results;
    }).call(this));
  };

  this.find_all_names = function() {
    var id, me, probes;
    me = arguments[0], probes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return unique((function() {
      var i, len, ref, results;
      ref = this.find_all_ids(me, probes);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        id = ref[i];
        results.push(this.get_name(me, id));
      }
      return results;
    }).call(this));
  };

  unique = function(list) {
    var R, element, i, len, seen;
    seen = new Set();
    R = [];
    for (i = 0, len = list.length; i < len; i++) {
      element = list[i];
      if (seen.has(element)) {
        continue;
      }
      seen.add(element);
      R.push(element);
    }
    return R;
  };

}).call(this);

//# sourceMappingURL=main.js.map
