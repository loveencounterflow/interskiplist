// Generated by CoffeeScript 1.10.0
(function() {
  var CND, ISL, alert, badge, debug, echo, find_ids_text, find_names_text, help, hex, include, info, list, log, rpr, show, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'INTERSKIPLIST/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  ISL = require('./main');

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this._main = function() {
    return test(this, {
      'timeout': 3000
    });
  };

  hex = function(n) {
    return '0x' + n.toString(16);
  };

  find_ids_text = function() {
    var P, R, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    R = ISL.find_ids_with_all_points.apply(ISL, [me].concat(slice.call(P)));
    R.sort();
    return R.join(',');
  };

  find_names_text = function() {
    var P, R, me;
    me = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    R = ISL.find_names_with_all_points.apply(ISL, [me].concat(slice.call(P)));
    R.sort();
    return R.join(',');
  };

  list = function(me) {
    var _, entry, i, key, len, ref, ref1, ref2, type, value;
    ref = ISL.entries_of(me);
    for (i = 0, len = ref.length; i < len; i++) {
      entry = ref[i];
      ref2 = ((ref1 = entry['name']) != null ? ref1 : '???/').split(':'), type = ref2[0], _ = ref2[1];
      help((CND.grey(type + '/')) + (CND.steel('interval')) + ': ' + (CND.yellow((hex(entry['lo'])) + "-" + (hex(entry['hi'])))));
      for (key in entry) {
        value = entry[key];
        help((CND.grey(type + '/')) + (CND.steel(key)) + ': ' + (CND.yellow(value)));
      }
    }
    return null;
  };

  show = function(me) {
    var hi, hi_closed, id, left, lo, lo_closed, ref, ref1, results, right;
    echo('                      0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7         8         9         ');
    echo('                      01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789');
    debug('4921', me['min'], me['max']);
    ref = ISL.intervals_of(me);
    results = [];
    for (id in ref) {
      ref1 = ref[id], lo = ref1[0], hi = ref1[1];
      lo_closed = true;
      hi_closed = true;
      if (lo < 0) {
        lo = 0;
        lo_closed = false;
      }
      if (hi > 199) {
        hi = 199;
        hi_closed = false;
      }
      while (id.length < 20) {
        id += ' ';
      }
      if (lo > 199 && hi > 199) {
        echo(id(id + '  ' + (' '.repeat(199)) + '->'));
        continue;
      }
      if (lo === hi) {
        echo(id + '  ' + (' '.repeat(lo)) + 'H');
        continue;
      }
      left = lo_closed ? '[' : '-';
      right = hi_closed ? ']' : '-';
      results.push(echo(id + '  ' + (' '.repeat(lo)) + left + ('-'.repeat(hi - lo - 1)) + right));
    }
    return results;
  };

  this["test interval tree 1"] = function(T) {
    var hi, i, id, intervals, isl, len, lo, ref;
    isl = ISL["new"]();
    intervals = [[1, 3, 'A'], [2, 14, 'B'], [3, 7, 'C'], [4, 4, 'D'], [5, 7, 'E'], [8, 12, 'F1'], [8, 12, 'F2'], [8, 22, 'G'], [10, 13, 'H']];
    for (i = 0, len = intervals.length; i < len; i++) {
      ref = intervals[i], lo = ref[0], hi = ref[1], id = ref[2];
      ISL.insert(isl, {
        lo: lo,
        hi: hi,
        id: id
      });
    }
    show(isl);
    T.eq(find_ids_text(isl, 0), '');
    T.eq(find_ids_text(isl, 1), 'A');
    T.eq(find_ids_text(isl, 2), 'A,B');
    T.eq(find_ids_text(isl, 3), 'A,B,C');
    T.eq(find_ids_text(isl, 4), 'B,C,D');
    T.eq(find_ids_text(isl, 5), 'B,C,E');
    T.eq(find_ids_text(isl, 6), 'B,C,E');
    T.eq(find_ids_text(isl, 7), 'B,C,E');
    T.eq(find_ids_text(isl, 8), 'B,F1,F2,G');
    T.eq(find_ids_text(isl, 9), 'B,F1,F2,G');
    T.eq(find_ids_text(isl, 10), 'B,F1,F2,G,H');
    T.eq(find_ids_text(isl, 11), 'B,F1,F2,G,H');
    T.eq(find_ids_text(isl, 12), 'B,F1,F2,G,H');
    T.eq(find_ids_text(isl, 13), 'B,G,H');
    T.eq(find_ids_text(isl, 14), 'B,G');
    T.eq(find_ids_text(isl, 15), 'G');
    T.eq(find_ids_text(isl, 16), 'G');
    T.eq(find_ids_text(isl, 17), 'G');
    T.eq(find_ids_text(isl, 18), 'G');
    return null;
  };

  this["test interval tree 2"] = function(T) {
    var hi, i, intervals, isl, len, lo, name, ref;
    isl = ISL["new"]();
    intervals = [[1, 3, 'orion'], [2, 14, 'orion'], [3, 7, 'orion'], [4, 4, 'orion'], [5, 7, 'cygnus'], [5, 7, 'orion'], [8, 12, 'aldebaran'], [-12, 8, 'aldebaran'], [8, 22, 'aldebaran'], [10, 13, 'aldebaran'], [11, 15, 'cygnus']];
    for (i = 0, len = intervals.length; i < len; i++) {
      ref = intervals[i], lo = ref[0], hi = ref[1], name = ref[2];
      ISL.insert(isl, {
        lo: lo,
        hi: hi,
        name: name
      });
    }
    show(isl);
    T.eq(find_names_text(isl, 0), "aldebaran");
    T.eq(find_names_text(isl, 1), "aldebaran,orion");
    T.eq(find_names_text(isl, 2), "aldebaran,orion");
    T.eq(find_names_text(isl, 3), "aldebaran,orion");
    T.eq(find_names_text(isl, 4), "aldebaran,orion");
    T.eq(find_names_text(isl, 5), "aldebaran,cygnus,orion");
    T.eq(find_names_text(isl, 6), "aldebaran,cygnus,orion");
    T.eq(find_names_text(isl, 7), "aldebaran,cygnus,orion");
    T.eq(find_names_text(isl, 8), "aldebaran,orion");
    T.eq(find_names_text(isl, 9), "aldebaran,orion");
    T.eq(find_names_text(isl, 10), "aldebaran,orion");
    T.eq(find_names_text(isl, 11), "aldebaran,cygnus,orion");
    T.eq(find_names_text(isl, 12), "aldebaran,cygnus,orion");
    T.eq(find_names_text(isl, 13), "aldebaran,cygnus,orion");
    T.eq(find_names_text(isl, 14), "aldebaran,cygnus,orion");
    T.eq(find_names_text(isl, 15), "aldebaran,cygnus");
    T.eq(find_names_text(isl, 16), "aldebaran");
    T.eq(find_names_text(isl, 17), "aldebaran");
    T.eq(find_names_text(isl, 18), "aldebaran");
    return null;
  };

  this["test interval tree 3"] = function(T) {
    var entry, error_count, hi, i, intervals, isl, len, lo, name, ref, type;
    isl = ISL["new"]();
    intervals = [[17, 19, 'plane', 'A'], [5, 8, 'plane', 'B'], [21, 24, 'block', 'A'], [4, 8, 'block', 'D']];
    for (i = 0, len = intervals.length; i < len; i++) {
      ref = intervals[i], lo = ref[0], hi = ref[1], type = ref[2], name = ref[3];
      ISL.insert(isl, {
        lo: lo,
        hi: hi,
        type: type,
        name: name
      });
    }
    show(isl);
    error_count = 0;
    debug(ISL.find_entries_with_any_points(isl, [18, 22]));
    debug((function() {
      var j, len1, ref1, results;
      ref1 = ISL.find_entries_with_any_points(isl, [18, 22]);
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        entry = ref1[j];
        if (entry['type'] === 'block') {
          results.push(entry);
        }
      }
      return results;
    })());
    return null;
  };

  this["new API for points"] = function(T) {
    var hi, i, intervals, isl, len, lo, name, ref, type;
    isl = ISL["new"]();
    intervals = [[17, 19, 'plane', 'A'], [5, 8, 'plane', 'B'], [21, 24, 'block', 'A'], [4, 8, 'block', 'D']];
    for (i = 0, len = intervals.length; i < len; i++) {
      ref = intervals[i], lo = ref[0], hi = ref[1], type = ref[2], name = ref[3];
      ISL.insert(isl, {
        lo: lo,
        hi: hi,
        type: type,
        name: name
      });
    }
    ISL.find_ids_with_any_points(isl, 7);
    ISL.find_ids_with_any_points(isl, [7]);
    ISL.find_ids_with_any_points(isl, [7, 8]);
    T.throws('expected 2 arguments, got 3', function() {
      return ISL.find_ids_with_any_points(isl, 7, 8);
    });
    T.throws('expected 2 arguments, got 3', function() {
      return ISL.find_ids_with_all_points(isl, 7, 8);
    });
    T.throws('expected a POD for reducer, got a number', function() {
      return ISL.aggregate(isl, 7, 8);
    });
    return null;
  };

  this["characters as points 1"] = function(T) {
    var a_cid, entry, isl, z_cid;
    a_cid = 'a'.codePointAt(0);
    z_cid = 'z'.codePointAt(0);
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: a_cid,
      hi: z_cid,
      name: 'Basic Latin:Lower Case'
    });
    entry = (ISL.entries_of(isl))[0];
    T.eq(entry['lo'], a_cid);
    T.eq(entry['hi'], z_cid);
    T.eq(isl['min'], a_cid);
    T.eq(isl['max'], z_cid);
    T.eq(isl['fmin'], a_cid);
    T.eq(isl['fmax'], z_cid);
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: 'a',
      hi: 'z',
      name: 'Basic Latin:Lower Case'
    });
    entry = (ISL.entries_of(isl))[0];
    T.eq(entry['lo'], a_cid);
    T.eq(entry['hi'], z_cid);
    T.eq(isl['min'], a_cid);
    T.eq(isl['max'], z_cid);
    T.eq(isl['fmin'], a_cid);
    T.eq(isl['fmax'], z_cid);
    return null;
  };

  this["characters as points 2"] = function(T) {
    var A_cid, C_cid, Z_cid, a_cid, c_cid, isl, z_cid;
    a_cid = 'a'.codePointAt(0);
    z_cid = 'z'.codePointAt(0);
    A_cid = 'A'.codePointAt(0);
    Z_cid = 'Z'.codePointAt(0);
    c_cid = 'c'.codePointAt(0);
    C_cid = 'C'.codePointAt(0);
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: a_cid,
      hi: z_cid,
      name: 'letter'
    });
    ISL.insert(isl, {
      lo: A_cid,
      hi: Z_cid,
      name: 'letter'
    });
    ISL.insert(isl, {
      lo: a_cid,
      hi: z_cid,
      name: 'lower'
    });
    ISL.insert(isl, {
      lo: A_cid,
      hi: Z_cid,
      name: 'upper'
    });
    T.eq(find_names_text(isl, [c_cid]), 'letter,lower');
    T.eq(find_names_text(isl, [C_cid]), 'letter,upper');
    T.eq(find_names_text(isl, [c_cid, C_cid]), 'letter');
    T.eq(find_names_text(isl, [C_cid, C_cid]), 'letter,upper');
    T.eq(find_names_text(isl, [C_cid, A_cid]), 'letter,upper');
    T.eq(find_names_text(isl, [c_cid, A_cid]), 'letter');
    return null;
  };

  this["characters as points 3"] = function(T) {
    var chr, i, isl, j, k, len, len1, len2, ref, ref1, ref2;
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: 0x00,
      hi: 0x7f,
      name: 'basic-latin'
    });
    ISL.insert(isl, {
      lo: 'a',
      hi: 'z',
      name: 'letter'
    });
    ISL.insert(isl, {
      lo: 'A',
      hi: 'Z',
      name: 'letter'
    });
    ISL.insert(isl, {
      lo: 'a',
      hi: 'z',
      name: 'lower'
    });
    ISL.insert(isl, {
      lo: 'A',
      hi: 'Z',
      name: 'upper'
    });
    ref = 'aeiouAEIOU';
    for (i = 0, len = ref.length; i < len; i++) {
      chr = ref[i];
      ISL.insert(isl, {
        lo: chr,
        hi: chr,
        name: 'vowel'
      });
    }
    ref1 = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ';
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      chr = ref1[j];
      ISL.insert(isl, {
        lo: chr,
        hi: chr,
        name: 'consonant'
      });
    }
    ref2 = '0123456789';
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      chr = ref2[k];
      ISL.insert(isl, {
        lo: chr,
        hi: chr,
        name: 'digit'
      });
    }
    T.eq(find_names_text(isl, ['c']), 'basic-latin,consonant,letter,lower');
    T.eq(find_names_text(isl, ['C']), 'basic-latin,consonant,letter,upper');
    T.eq(find_names_text(isl, ['c', 'C']), 'basic-latin,consonant,letter');
    T.eq(find_names_text(isl, ['C', 'C']), 'basic-latin,consonant,letter,upper');
    T.eq(find_names_text(isl, ['C', 'A']), 'basic-latin,letter,upper');
    T.eq(find_names_text(isl, ['c', 'A']), 'basic-latin,letter');
    T.eq(find_names_text(isl, ['A', 'e']), 'basic-latin,letter,vowel');
    T.eq(find_names_text(isl, ['i', 'e']), 'basic-latin,letter,lower,vowel');
    T.eq(find_names_text(isl, ['2', 'e']), 'basic-latin');
    return null;
  };

  this["intervals_from_points"] = function(T) {
    var A_cid, B_cid, C_cid, X_cid, Y_cid, Z_cid, isl;
    isl = ISL["new"]();
    T.eq(ISL.intervals_from_points(isl, [3, 4, 5]), [
      {
        lo: 3,
        hi: 5
      }
    ]);
    T.eq(ISL.intervals_from_points(isl, [3, 4, 5, 7, 8, 9, 10]), [
      {
        lo: 3,
        hi: 5
      }, {
        lo: 7,
        hi: 10
      }
    ]);
    T.eq(ISL.intervals_from_points(isl, [7, 10]), [
      {
        lo: 7,
        hi: 7
      }, {
        lo: 10,
        hi: 10
      }
    ]);
    A_cid = 'A'.codePointAt(0);
    B_cid = 'B'.codePointAt(0);
    C_cid = 'C'.codePointAt(0);
    X_cid = 'X'.codePointAt(0);
    Y_cid = 'Y'.codePointAt(0);
    Z_cid = 'Z'.codePointAt(0);
    T.eq(ISL.intervals_from_points(isl, Array.from('CBABAXZY')), [
      {
        lo: A_cid,
        hi: C_cid
      }, {
        lo: X_cid,
        hi: Z_cid
      }
    ]);
    T.eq(ISL.intervals_from_points(isl, Array.from('CBABAXZY'), {
      name: 'foo'
    }), [
      {
        lo: A_cid,
        hi: C_cid,
        name: 'foo'
      }, {
        lo: X_cid,
        hi: Z_cid,
        name: 'foo'
      }
    ]);
    return null;
  };

  this["intervals without ID, name"] = function(T) {
    var isl;
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: 'a',
      'hi': 'z'
    });
    ISL.insert(isl, {
      lo: 'a',
      'hi': 'k',
      id: 'lower-half'
    });
    ISL.insert(isl, {
      lo: 'l',
      'hi': 'z',
      name: 'upper-half'
    });
    T.eq(ISL.find_entries_with_any_points(isl, ['c', 'm']), [
      {
        "lo": 97,
        "hi": 122,
        "idx": 0,
        "id": "+[0]",
        "name": "+",
        "size": 26
      }, {
        "lo": 97,
        "hi": 107,
        "id": "lower-half",
        "idx": 1,
        "name": "+",
        "size": 11
      }, {
        "lo": 108,
        "hi": 122,
        "name": "upper-half",
        "idx": 2,
        "id": "upper-half[0]",
        "size": 15
      }
    ]);
    return null;
  };

  this["aggregation 1"] = function(T) {

    /*
    《 0x300a
     */
    var entries, entry, i, isl, len, replacers;
    entries = [
      {
        lo: 0x0,
        hi: 0x10ffff,
        type: 'style',
        name: 'fallback',
        tex: 'mktsRsgFb'
      }, {
        lo: 0x0,
        hi: 0xffff,
        type: 'plane',
        name: 'Basic Multilingual Plane (BMP)'
      }, {
        lo: 0x2e80,
        hi: 0x33ff,
        type: 'area',
        name: 'CJK Miscellaneous Area'
      }, {
        lo: 0x3000,
        hi: 0x303f,
        type: 'block',
        name: 'CJK Symbols and Punctuation',
        rsg: 'u-cjk-sym',
        is_cjk: true,
        tex: 'cnsymOld'
      }, {
        lo: 0x3000,
        hi: 0x303f,
        type: 'block',
        name: 'CJK Symbols and Punctuation',
        rsg: 'u-cjk-sym',
        is_cjk: true,
        tex: 'cnsymNew'
      }, {
        lo: 0x300a,
        hi: 0x300a,
        type: 'style',
        name: 'glyph-0x300a',
        rsg: 'u-cjk-sym',
        style: {
          raise: -0.2
        }
      }
    ];
    isl = ISL["new"]();
    for (i = 0, len = entries.length; i < len; i++) {
      entry = entries[i];
      ISL.insert(isl, entry);
    }
    replacers = {
      type: 'list',
      style: 'list',
      tex: 'list',
      rsg: 'assign'
    };
    entry = ISL.aggregate(isl, '《'.codePointAt(0), replacers);
    debug(JSON.stringify(entry));
    help(entry);
    T.eq(entry, {
      type: ['style', 'plane', 'area', 'block', 'block', 'style'],
      name: 'glyph-0x300a',
      tex: ['mktsRsgFb', 'cnsymOld', 'cnsymNew'],
      rsg: 'u-cjk-sym',
      is_cjk: true,
      style: [
        {
          raise: -0.2
        }
      ]
    });
    return null;
  };

  this["aggregation 2"] = function(T) {
    var aggregation_settings, isl;
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: 0,
      hi: 10,
      id: 'wide',
      count: 10,
      length: 10,
      foo: 'D'
    });
    ISL.insert(isl, {
      lo: 3,
      hi: 7,
      id: 'narrow',
      count: 4,
      length: 4,
      foo: 'UH'
    });
    aggregation_settings = {
      '*': 'list',
      id: 'include',
      lo: 'assign',
      hi: 'assign',
      name: 'assign',
      count: 'add',
      length: 'average',
      foo: function(ids_and_values) {
        var id, value;
        return (((function() {
          var i, len, ref, results;
          results = [];
          for (i = 0, len = ids_and_values.length; i < len; i++) {
            ref = ids_and_values[i], id = ref[0], value = ref[1];
            results.push(value.toLowerCase());
          }
          return results;
        })()).join('')) + '!';
      }
    };
    debug(JSON.stringify(ISL.aggregate(isl, 5, aggregation_settings)));
    T.eq(ISL.aggregate(isl, 5, aggregation_settings), {
      "lo": 3,
      "hi": 7,
      "id": ["wide", "narrow"],
      "count": 14,
      "name": "+",
      "length": 7,
      "foo": "duh!"
    });
    return null;
  };

  this["readme example 1"] = function(T) {
    var chr, consonants, digits, i, interval, isl, j, k, len, len1, len2, ref, ref1, ref2;
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: 0x00,
      hi: 0x7f,
      name: 'basic-latin'
    });
    ISL.insert(isl, {
      lo: 'a',
      hi: 'z',
      name: 'letter'
    });
    ISL.insert(isl, {
      lo: 'A',
      hi: 'Z',
      name: 'letter'
    });
    ISL.insert(isl, {
      lo: 'a',
      hi: 'z',
      name: 'lower'
    });
    ISL.insert(isl, {
      lo: 'A',
      hi: 'Z',
      name: 'upper'
    });
    ref = 'aeiouAEIOU';
    for (i = 0, len = ref.length; i < len; i++) {
      chr = ref[i];
      ISL.insert(isl, {
        lo: chr,
        hi: chr,
        name: 'vowel'
      });
    }
    consonants = Array.from('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ');
    ref1 = ISL.intervals_from_points(isl, consonants, {
      name: 'consonant'
    });
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      interval = ref1[j];
      ISL.insert(isl, interval);
    }
    digits = Array.from('0123456789');
    ref2 = ISL.intervals_from_points(isl, digits, {
      name: 'digit'
    });
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      interval = ref2[k];
      ISL.insert(isl, interval);
    }
    show(isl);
    console.log(ISL.find_names_with_all_points(isl, ['c']));
    console.log(ISL.find_names_with_all_points(isl, ['C']));
    console.log(ISL.find_names_with_all_points(isl, ['c', 'C']));
    console.log(ISL.find_names_with_all_points(isl, ['C', 'C']));
    console.log(ISL.find_names_with_all_points(isl, ['C', 'A']));
    console.log(ISL.find_names_with_all_points(isl, ['c', 'A']));
    console.log(ISL.find_names_with_all_points(isl, ['A', 'e']));
    console.log(ISL.find_names_with_all_points(isl, ['i', 'e']));
    console.log(ISL.find_names_with_all_points(isl, ['2', 'e']));
    return null;
  };

  this["readme example 2"] = function(T) {
    var replacers, samples;
    samples = ISL["new"]();
    ISL.insert(samples, {
      lo: 0x0000,
      hi: 0x10ffff,
      name: 'base',
      font_family: 'Arial'
    });
    ISL.insert(samples, {
      lo: 0x00,
      hi: 0xff,
      name: 'ascii',
      font_family: 'Arial'
    });
    ISL.insert(samples, {
      lo: 0x4e00,
      hi: 0x9fff,
      name: 'cjk',
      font_family: 'Sun-ExtA'
    });
    ISL.insert(samples, {
      lo: 0x3040,
      hi: 0x309f,
      name: 'cjk',
      font_family: 'Sun-ExtA'
    });
    ISL.insert(samples, {
      lo: 0x26,
      hi: 0x26,
      name: 'ampersand',
      font_family: 'Baskerville'
    });
    debug('rx2-1', 'A', ISL.find_names_with_all_points(samples, 'A'));
    debug('rx2-2', '&', ISL.find_names_with_all_points(samples, '&'));
    debug('rx2-3', '人', ISL.find_names_with_all_points(samples, '人'));
    debug('rx2-3', 'Abcd人', ISL.find_names_with_all_points(samples, Array.from('Abcd人')));
    debug('rx2-3', '人はるのそらのした', ISL.find_names_with_all_points(samples, Array.from('人はるのそらのした')));
    T.eq(ISL.find_names_with_all_points(samples, 'A'), ISL.find_names(samples, 'A'));
    T.eq(ISL.find_names_with_all_points(samples, '&'), ISL.find_names(samples, '&'));
    T.eq(ISL.find_names_with_all_points(samples, '人'), ISL.find_names(samples, '人'));
    T.eq(ISL.find_ids_with_all_points(samples, 'A'), ISL.find_ids(samples, 'A'));
    T.eq(ISL.find_ids_with_all_points(samples, '&'), ISL.find_ids(samples, '&'));
    T.eq(ISL.find_ids_with_all_points(samples, '人'), ISL.find_ids(samples, '人'));
    T.eq(ISL.find_intervals_with_all_points(samples, 'A'), ISL.find_intervals(samples, 'A'));
    T.eq(ISL.find_intervals_with_all_points(samples, '&'), ISL.find_intervals(samples, '&'));
    T.eq(ISL.find_intervals_with_all_points(samples, '人'), ISL.find_intervals(samples, '人'));
    T.eq(ISL.find_entries_with_all_points(samples, 'A'), ISL.find_entries(samples, 'A'));
    T.eq(ISL.find_entries_with_all_points(samples, '&'), ISL.find_entries(samples, '&'));
    T.eq(ISL.find_entries_with_all_points(samples, '人'), ISL.find_entries(samples, '人'));
    urge('rx2-7', 'A', ISL.aggregate(samples, 'A'));
    urge('rx2-8', '&', ISL.aggregate(samples, '&'));
    urge('rx2-9', '人', ISL.aggregate(samples, '人'));
    replacers = {
      '*': 'list',
      name: 'include'
    };
    info('rx2-10', 'A', ISL.aggregate(samples, 'A', replacers));
    info('rx2-11', '&', ISL.aggregate(samples, '&', replacers));
    info('rx2-12', '人', ISL.aggregate(samples, '人', replacers));
    return null;
  };

  this["preserve insertion order"] = function(T) {
    var isl, names_by_insertion_order;
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: 10,
      hi: 20,
      id: 'foo',
      name: 'alpha'
    });
    ISL.insert(isl, {
      lo: 15,
      hi: 25,
      id: 'bar',
      name: 'beta'
    });
    ISL.insert(isl, {
      lo: 15,
      hi: 25,
      id: '22',
      name: '0'
    });
    ISL.insert(isl, {
      lo: 19,
      hi: 29,
      id: 'baz',
      name: 'beta'
    });
    ISL.insert(isl, {
      lo: 39,
      hi: 49,
      id: 'gnu',
      name: 'gamma'
    });
    names_by_insertion_order = ['alpha', '0', 'beta', 'gamma'];
    T.eq(ISL.names_of(isl, ['22', 'foo', 'bar', 'baz', 'gnu']), names_by_insertion_order);
    T.eq(ISL.names_of(isl, ['foo', 'baz', 'gnu', 'bar', '22']), names_by_insertion_order);
    T.eq(ISL.names_of(isl, ['baz', 'bar', '22', 'gnu', 'foo']), names_by_insertion_order);
    T.eq(ISL.names_of(isl, ['bar', 'foo', 'baz', 'gnu', '22']), names_by_insertion_order);
    return null;
  };

  this["demo discontiguous ranges"] = function(T) {
    var u;
    u = ISL["new"]();
    ISL.insert(u, {
      lo: 0x4e00,
      hi: 0x9fff,
      name: 'cjk',
      id: 'u-cjk'
    });
    ISL.insert(u, {
      lo: 0xff00,
      hi: 0xffef,
      name: 'cjk',
      id: 'u-halfull'
    });
    ISL.insert(u, {
      lo: 0x3400,
      hi: 0x4dbf,
      name: 'cjk',
      id: 'u-cjk-xa'
    });
    ISL.insert(u, {
      lo: 0x20000,
      hi: 0x2a6df,
      name: 'cjk',
      id: 'u-cjk-xb'
    });
    ISL.insert(u, {
      lo: 0x2a700,
      hi: 0x2b73f,
      name: 'cjk',
      id: 'u-cjk-xc'
    });
    ISL.insert(u, {
      lo: 0x2b740,
      hi: 0x2b81f,
      name: 'cjk',
      id: 'u-cjk-xd'
    });
    ISL.insert(u, {
      lo: 0x2b820,
      hi: 0x2ceaf,
      name: 'cjk',
      id: 'u-cjk-xe'
    });
    ISL.insert(u, {
      lo: 0xf900,
      hi: 0xfaff,
      name: 'cjk',
      id: 'u-cjk-cmpi1'
    });
    ISL.insert(u, {
      lo: 0x2f800,
      hi: 0x2fa1f,
      name: 'cjk',
      id: 'u-cjk-cmpi2'
    });
    ISL.insert(u, {
      lo: 0x2f00,
      hi: 0x2fdf,
      name: 'cjk',
      id: 'u-cjk-rad1'
    });
    ISL.insert(u, {
      lo: 0x2e80,
      hi: 0x2eff,
      name: 'cjk',
      id: 'u-cjk-rad2'
    });
    ISL.insert(u, {
      lo: 0x3000,
      hi: 0x303f,
      name: 'cjk',
      id: 'u-cjk-sym'
    });
    ISL.insert(u, {
      lo: 0x31c0,
      hi: 0x31ef,
      name: 'cjk',
      id: 'u-cjk-strk'
    });
    ISL.insert(u, {
      lo: 0x30a0,
      hi: 0x30ff,
      name: 'cjk',
      id: 'u-cjk-kata'
    });
    ISL.insert(u, {
      lo: 0x3040,
      hi: 0x309f,
      name: 'cjk',
      id: 'u-cjk-hira'
    });
    ISL.insert(u, {
      lo: 0xac00,
      hi: 0xd7af,
      name: 'cjk',
      id: 'u-hang-syl'
    });
    ISL.insert(u, {
      lo: 0x3200,
      hi: 0x32ff,
      name: 'cjk',
      id: 'u-cjk-enclett'
    });
    return Array.from('');
  };

  this["unique names with priority conflict"] = function(T) {
    var isl;
    isl = ISL["new"]();
    ISL.insert(isl, {
      lo: 15,
      hi: 20,
      id: 'alpha-0',
      name: 'alpha'
    });
    ISL.insert(isl, {
      lo: 15,
      hi: 25,
      id: 'beta-0',
      name: 'beta'
    });
    ISL.insert(isl, {
      lo: 15,
      hi: 25,
      id: 'omega-0',
      name: 'omega'
    });
    ISL.insert(isl, {
      lo: 15,
      hi: 49,
      id: 'gamma-0',
      name: 'gamma'
    });
    ISL.insert(isl, {
      lo: 15,
      hi: 29,
      id: 'beta-1',
      name: 'beta'
    });
    show(isl);
    debug('3928', JSON.stringify(ISL.find_ids(isl, 15)));
    debug('3928', JSON.stringify(ISL.find_names(isl, 15)));
    return null;
  };

  if (module.parent == null) {
    include = ["test interval tree 1", "test interval tree 2", "test interval tree 3", "aggregation 1", "aggregation 2", "characters as points 1", "characters as points 2", "characters as points 3", "intervals_from_points", "new API for points", "readme example 1", "readme example 2", "intervals without ID, name", "preserve insertion order", "demo discontiguous ranges", "unique names with priority conflict"];
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
