// Generated by CoffeeScript 1.10.0
(function() {
  var CND, ISL, alert, badge, debug, echo, find_id_text, help, hex, include, info, log, rpr, show, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'INTERSKIPLIST/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  ISL = require('./main');

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this._main = function() {
    return test(this, {
      'timeout': 3000
    });
  };

  hex = function(n) {
    return '0x' + n.toString(16);
  };

  find_id_text = function(me, probe) {
    var R;
    R = ISL.find_any_ids(me, probe);
    R.sort();
    return R.join(',');
  };

  show = function(me) {
    var hi, id, lo, ref, ref1, ref2, results;
    echo('  0         1         2         3         4         5         6         7         8         ');
    echo('  012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789');
    ref = ISL.get_intervals(me);
    results = [];
    for (id in ref) {
      ref1 = ref[id], lo = ref1[0], hi = ref1[1];
      if (lo > hi) {
        ref2 = [hi, lo], lo = ref2[0], hi = ref2[1];
      }
      if (lo === hi) {
        echo(id, (' '.repeat(lo)) + 'H');
        continue;
      }
      results.push(echo(id, (' '.repeat(lo)) + '[' + ('-'.repeat(hi - lo - 1)) + ']'));
    }
    return results;
  };


  /*
  #-----------------------------------------------------------------------------------------------------------
  @_demo = ->
    badge = 'CND/INTERSKIPLIST/demo'
    help  = CND.get_logger 'help',      badge
    urge  = CND.get_logger 'urge',      badge
    SL    = @
    show  = ( node ) ->
      this_key    = node[ 'key' ]
      this_value  = node[ 'value' ]
      this_m      = node[ get_m_sym ]()
      help this_key, this_value, this_m
      show left_node  if (  left_node = node[ 'left'  ] )?
      show right_node if ( right_node = node[ 'right' ] )?
      return null
    skiplist  = SL.new()
     * intervals = [
     *   [ 3, 7, 'A', ]
     *   [ 5, 7, 'B', ]
     *   [ 8, 12, 'C1', ]
     *   [ 8, 12, 'C2', ]
     *   [ 2, 14, 'D', null ]
     *   [ 4, 4, 'E', [ 'helo', ] ]
     *   [ 10, 13, 'F', ]
     *   [ 8, 22, 'G', ]
     *   [ 1, 3, 'H', ]
     *   ]
    intervals = [
      [ 1, 3, 'A', ]
      [ 2, 14, 'B', ]
      [ 3, 7, 'C', ]
      [ 4, 4, 'D', ]
      [ 5, 7, 'E', ]
      [ 8, 12, 'F1', ]
      [ 8, 12, 'F2', ]
      [ 8, 22, 'G', ]
      [ 10, 13, 'H', ]
      ]
    for [ lo, hi, id, value, ] in intervals
      SL.add_interval skiplist, lo, hi, id, value
    for n in [ 0 .. 15 ]
      help n, \
        ( ( SL.find_any_ids skiplist, n ).join ',' ), \
        ( SL.find_any_intervals skiplist, n ), \
        ( SL.find_any_values skiplist, n )
     * show skiplist[ '%self' ][ 'root' ]
     * SL.add_interval skiplist, [ 10, 13, 'FF' ]
    return null
   */

  this["test interval tree 1"] = function(T) {
    var hi, i, id, intervals, isl, len, lo, ref, value;
    isl = ISL["new"]();
    intervals = [[1, 3, 'A'], [2, 14, 'B'], [3, 7, 'C'], [4, 4, 'D'], [5, 7, 'E'], [8, 12, 'F1'], [8, 12, 'F2'], [8, 22, 'G'], [10, 13, 'H']];
    for (i = 0, len = intervals.length; i < len; i++) {
      ref = intervals[i], lo = ref[0], hi = ref[1], id = ref[2], value = ref[3];
      ISL.add_interval(isl, lo, hi, id, value);
    }
    show(isl);
    T.eq(find_id_text(isl, 0), '');
    T.eq(find_id_text(isl, 1), 'A');
    T.eq(find_id_text(isl, 2), 'A,B');
    T.eq(find_id_text(isl, 3), 'A,B,C');
    T.eq(find_id_text(isl, 4), 'B,C,D');
    T.eq(find_id_text(isl, 5), 'B,C,E');
    T.eq(find_id_text(isl, 6), 'B,C,E');
    T.eq(find_id_text(isl, 7), 'B,C,E');
    T.eq(find_id_text(isl, 8), 'B,F1,F2,G');
    T.eq(find_id_text(isl, 9), 'B,F1,F2,G');
    T.eq(find_id_text(isl, 10), 'B,F1,F2,G,H');
    T.eq(find_id_text(isl, 11), 'B,F1,F2,G,H');
    T.eq(find_id_text(isl, 12), 'B,F1,F2,G,H');
    T.eq(find_id_text(isl, 13), 'B,G,H');
    T.eq(find_id_text(isl, 14), 'B,G');
    T.eq(find_id_text(isl, 15), 'G');
    T.eq(find_id_text(isl, 16), 'G');
    T.eq(find_id_text(isl, 17), 'G');
    T.eq(find_id_text(isl, 18), 'G');
    return null;
  };

  this["test interval tree 2"] = function(T) {
    var error_count, i, interval, intervals, isl, len;
    isl = ISL["new"]();
    intervals = [[17, 19, 'A'], [5, 8, 'B'], [21, 24, 'C'], [4, 8, 'D'], [15, 18, 'E'], [7, 10, 'F'], [16, 22, 'G']];
    for (i = 0, len = intervals.length; i < len; i++) {
      interval = intervals[i];
      ISL.add_interval.apply(ISL, [isl].concat(slice.call(interval)));
    }
    show(isl);
    error_count = 0;
    debug(rpr(find_id_text(isl, [8, 9])));
    debug(rpr(find_id_text(isl, [5, 8])));
    debug(rpr(find_id_text(isl, [21, 24])));
    debug(rpr(find_id_text(isl, [4, 8])));
    if (error_count !== 0) {
      throw Error("there were " + error_count + " errors");
    }
    return null;
  };

  this["Unicode demo"] = function(T) {
    var cid, cid_hex, csg, glyph, hi, i, j, last_cid, len, len1, lo, name, page_id, page_idx, range, ranges, ref, ref1, rsg, rsg_registry, unicode_areas;
    unicode_areas = ISL["new"]();
    last_cid = 0x10ffff;
    page_idx = -1;
    while (true) {
      page_idx += 1;
      page_id = "page-x" + (page_idx.toString(16));
      lo = page_idx * 0x80;
      hi = lo + 0x7f;
      ISL.add_interval(unicode_areas, lo, hi, page_id);
      if (lo > last_cid) {
        break;
      }
    }
    rsg_registry = require('../../../ncr/lib/character-sets-and-ranges');
    ref = rsg_registry['names-and-ranges-by-csg'];
    for (csg in ref) {
      ranges = ref[csg];
      if (csg !== 'u' && csg !== 'jzr') {
        continue;
      }
      for (i = 0, len = ranges.length; i < len; i++) {
        range = ranges[i];
        name = range['range-name'];
        rsg = range['rsg'];
        lo = range['first-cid'];
        hi = range['last-cid'];
        ISL.add_interval(unicode_areas, lo, hi, name, {
          name: name,
          lo: lo,
          hi: hi,
          rsg: rsg
        });
      }
    }
    ref1 = Array.from("helo äöü你好𢕒𡕴𡕨𠤇");
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      glyph = ref1[j];
      cid = glyph.codePointAt(0);
      cid_hex = hex(cid);
      help(glyph, cid_hex, JSON.stringify(ISL.find_all_values(unicode_areas, cid)));
    }
    return null;
  };

  if (module.parent == null) {
    include = ["test interval tree 1", "test interval tree 2"];
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
